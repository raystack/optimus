package github

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"runtime"
	"strings"

	"github.com/odpf/optimus/client/extension/factory"
	"github.com/odpf/optimus/client/extension/model"
)

const provider = "github"

// Client defines github client
type Client struct {
}

// DownloadRelease downloads a release based on the API path
func (*Client) DownloadRelease(ctx context.Context, apiPath string) (*model.RepositoryRelease, error) {
	if apiPath == "" {
		return nil, model.ErrEmptyAPIPath
	}
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, apiPath, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	request.Header.Set("Accept", "application/json")

	httpClient := http.DefaultClient
	response, err := httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("error sending request: %w", err)
	}
	defer response.Body.Close()
	if response.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status response: %s", response.Status)
	}

	var release Release
	decoder := json.NewDecoder(response.Body)
	if err := decoder.Decode(&release); err != nil {
		return nil, fmt.Errorf("error decoding response: %w", err)
	}
	return release.toRepositoryRelease(apiPath), nil
}

// DownloadAsset downloads github asset based on the asset api path.
// Currently, it can only download asset from publicly available repository.
// `apiPath` follows prefix [https://api.github.com/repos], which can be
// generated by this provider parser. For more information,
// check [this](https://docs.github.com/en/rest/releases/releases) documentation.
func (c *Client) DownloadAsset(ctx context.Context, apiPath string) ([]byte, error) {
	if apiPath == "" {
		return nil, model.ErrEmptyAPIPath
	}
	release, err := c.DownloadRelease(ctx, apiPath)
	if err != nil {
		return nil, fmt.Errorf("error getting repository release: %w", err)
	}
	assetURL, err := c.getAssetURL(release)
	if err != nil {
		return nil, fmt.Errorf("error getting asset URL: %w", err)
	}
	return c.downloadAsset(ctx, assetURL)
}

func (*Client) downloadAsset(ctx context.Context, url string) ([]byte, error) {
	request, err := http.NewRequestWithContext(ctx, http.MethodGet, url, http.NoBody)
	if err != nil {
		return nil, fmt.Errorf("error creating request: %w", err)
	}
	request.Header.Set("Accept", "application/octet-stream")

	httpClient := http.DefaultClient
	response, err := httpClient.Do(request)
	if err != nil {
		return nil, fmt.Errorf("error getting release asset: %w", err)
	}
	defer response.Body.Close()
	if response.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status response: %s", response.Status)
	}

	return io.ReadAll(response.Body)
}

func (c *Client) getAssetURL(release *model.RepositoryRelease) (string, error) {
	suffix := c.getDistSuffix()
	for _, asset := range release.Assets {
		if strings.HasSuffix(asset.Name, suffix) {
			return asset.URL, nil
		}
	}
	return "", fmt.Errorf("asset with suffix [%s] is not found", suffix)
}

func (*Client) getDistSuffix() string {
	return runtime.GOOS + "-" + runtime.GOARCH
}

func init() { //nolint:gochecknoinits
	if err := factory.ClientRegistry.Add(provider, &Client{}); err != nil {
		panic(err)
	}
}
