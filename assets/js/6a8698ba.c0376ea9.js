"use strict";(self.webpackChunkoptimus=self.webpackChunkoptimus||[]).push([[1798],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return c}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=i.createContext({}),p=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=p(e.components);return i.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),m=p(t),c=a,h=m["".concat(l,".").concat(c)]||m[c]||d[c]||o;return t?i.createElement(h,s(s({ref:n},u),{},{components:t})):i.createElement(h,s({ref:n},u))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=m;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var p=2;p<o;p++)s[p]=t[p];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8013:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return u},default:function(){return m}});var i=t(7462),a=t(3366),o=(t(7294),t(3905)),s=["components"],r={id:"building-plugin",title:"Developing plugins"},l=void 0,p={unversionedId:"development/building-plugin",id:"development/building-plugin",isDocsHomePage:!1,title:"Developing plugins",description:"Optimus's responsibilities are currently divided in two parts, scheduling a transformation task and running one time action to create or modify a datastore resource. Defining how a datastore is managed can be easy and doesn't leave many options for configuration or ambiguity although the way datastores are implemented gives developers flexibility to contribute additional type of datastore, but it is not something we do every day.",source:"@site/docs/development/building-plugin.md",sourceDirName:"development",slug:"/development/building-plugin",permalink:"/optimus/docs/development/building-plugin",editUrl:"https://github.com/odpf/optimus/edit/master/docs/docs/development/building-plugin.md",tags:[],version:"current",lastUpdatedBy:"Yash Bhardwaj",lastUpdatedAt:1673425115,formattedLastUpdatedAt:"1/11/2023",frontMatter:{id:"building-plugin",title:"Developing plugins"},sidebar:"docsSidebar",previous:{title:"Understanding Intervals and Windows",permalink:"/optimus/docs/concepts/intervals-and-windows"},next:{title:"Contributing",permalink:"/optimus/docs/contribute/contributing"}},u=[{value:"Types of Plugins in Optimus",id:"types-of-plugins-in-optimus",children:[]},{value:"Supported Use-Cases of Plugins in Optimus",id:"supported-use-cases-of-plugins-in-optimus",children:[]},{value:"Binary Implementation of Plugin",id:"binary-implementation-of-plugin",children:[]},{value:"Yaml Implementation of Plugin",id:"yaml-implementation-of-plugin",children:[{value:"Limitations of Yaml plugins:",id:"limitations-of-yaml-plugins",children:[]},{value:"Validating Yaml plugins:",id:"validating-yaml-plugins",children:[]}]},{value:"Creating Plugin : Tutorial",id:"creating-plugin--tutorial",children:[{value:"1. Preparing task executor",id:"1-preparing-task-executor",children:[]},{value:"2a. Creating a yaml plugin",id:"2a-creating-a-yaml-plugin",children:[]},{value:"2b. Creating a binary plugin",id:"2b-creating-a-binary-plugin",children:[]},{value:"Building everything",id:"building-everything",children:[]}]},{value:"How to use",id:"how-to-use",children:[{value:"Installing a plugin",id:"installing-a-plugin",children:[]},{value:"Server-side installation",id:"server-side-installation",children:[]},{value:"Project-side installation",id:"project-side-installation",children:[]},{value:"Using in job specification",id:"using-in-job-specification",children:[]},{value:"Checking the output",id:"checking-the-output",children:[]}]},{value:"Additional details",id:"additional-details",children:[{value:"Requesting task context",id:"requesting-task-context",children:[]},{value:"Directory Structure",id:"directory-structure",children:[]},{value:"Secret management",id:"secret-management",children:[]}]}],d={toc:u};function m(e){var n=e.components,t=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,i.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Optimus's responsibilities are currently divided in two parts, scheduling a transformation ",(0,o.kt)("a",{parentName:"p",href:"/optimus/docs/concepts/overview#Job"},"task")," and running one time action to create or modify a ",(0,o.kt)("a",{parentName:"p",href:"/optimus/docs/concepts/overview#Datastore"},"datastore")," resource. Defining how a datastore is managed can be easy and doesn't leave many options for configuration or ambiguity although the way datastores are implemented gives developers flexibility to contribute additional type of datastore, but it is not something we do every day."),(0,o.kt)("p",null,"Whereas tasks used in jobs that define how the transformation will execute, what configuration does it need as input from user, how does this task resolves dependencies between each other, what kind of assets it might need. These questions are very open and answers to them could be different in  different organisation and users. To allow flexibility of answering these questions by developers themselves, we have chosen to make it easy to  contribute a new kind of task or even a hook. This modularity in Optimus is achieved using plugins."),(0,o.kt)("p",null,"Optimus can be divided in two logical parts when we are thinking of a pluggable model, one is the ",(0,o.kt)("strong",{parentName:"p"},"core")," where everything happens which is common for all job/datastore, and the other part which could be variable and needs user specific definitions of how things should work which is a ",(0,o.kt)("strong",{parentName:"p"},"plugin"),"."),(0,o.kt)("p",null,"Currently Optimus plugin can be implemented as binary executable.\nAnd ",(0,o.kt)("inlineCode",{parentName:"p"},"support for yaml")," implementation of plugins is also introduced with limited\nscope (discussed below)."),(0,o.kt)("p",null,"Optimus Plugin is just an adapter between optimus and  what actually needs to be executed. Actual transformation will be packed in a docker image and Optimus will execute these arbitrary docker images as long as it has access to reach container registry. Plugin provides the optimus server with the info about the docker image."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Plugin itself is not executed for transformation but only used for adapting conditions which Optimus requires to be defined for each task.")),(0,o.kt)("h2",{id:"types-of-plugins-in-optimus"},"Types of Plugins in Optimus"),(0,o.kt)("p",null,"At the moment mainly there are two types of plugins which optimus supports. These are : ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Hook"))," and  ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Task")),"\nBefore getting into the difference between two plugins ,we need to get familiar with ",(0,o.kt)("a",{parentName:"p",href:"/optimus/docs/concepts/overview#Job"},"Jobs"),"."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Task"),(0,o.kt)("th",{parentName:"tr",align:null},"Hook"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Definition"),(0,o.kt)("td",{parentName:"tr",align:null},"It is the single base transformation in a Job."),(0,o.kt)("td",{parentName:"tr",align:null},"It is the operation that we preferably run before or after a Job.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Fundamental Difference"),(0,o.kt)("td",{parentName:"tr",align:null},"It can have dependencies over other jobs inside the Optimus project."),(0,o.kt)("td",{parentName:"tr",align:null},"It can have dependencies over other hooks within the job.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Configuration"),(0,o.kt)("td",{parentName:"tr",align:null},"It has its own set of configs and asset directory."),(0,o.kt)("td",{parentName:"tr",align:null},"It has its own set of configs and share the same asset directory across all hooks as the base job.")))),(0,o.kt)("h2",{id:"supported-use-cases-of-plugins-in-optimus"},"Supported Use-Cases of Plugins in Optimus"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Plugin Info Usecases: ",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Discover all plugins and list their info."),(0,o.kt)("li",{parentName:"ul"},"Refer - ",(0,o.kt)("inlineCode",{parentName:"li"},"optimus version")," (lists all the plugins available),"))),(0,o.kt)("li",{parentName:"ul"},"Project Side Usecases :",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Survey to populate job specifications and assets."),(0,o.kt)("li",{parentName:"ul"},"Plugins provide the questionare and default values (default assets for job) to the survey implemtnation in optimus."),(0,o.kt)("li",{parentName:"ul"},"Refer -  ",(0,o.kt)("inlineCode",{parentName:"li"},"optimus job create")))),(0,o.kt)("li",{parentName:"ul"},"Server Side Usecases :",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"CompileAssets & DependencyResolver"),(0,o.kt)("li",{parentName:"ul"},"Theses are currently supported server side behaviour that is delegated to plugins implementations."),(0,o.kt)("li",{parentName:"ul"},"Refer - ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/odpf/transformers/blob/main/task/bq2bq/main.go#L274"},"transformers")," ")))),(0,o.kt)("h2",{id:"binary-implementation-of-plugin"},"Binary Implementation of Plugin"),(0,o.kt)("p",null,"Binary implementation of Plugins are self-contained binaries which implements predefined protobuf interfaces to extend Optimus functionalities.\nBinary Plugins are implemented using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/hashicorp/go-plugin"},"go-plugin")," developed by Hashicorp used in terraform and other similar products. "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Plugins can be implemented in any language as long as they can be exported as a single self-contained executable binary and implements a GRPC server. ")),(0,o.kt)("p",null,"It is recommended to use Go currently for writing plugins because of its cross platform build functionality and to reuse protobuf sdk provided within Optimus core. "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Binary Plugins can potentially modify the behavior of Optimus in undesired ways. Exercise caution when adding new plugins developed by unrecognized developers.")),(0,o.kt)("h2",{id:"yaml-implementation-of-plugin"},"Yaml Implementation of Plugin"),(0,o.kt)("p",null,"Most plugins are expected to implement just the info and project side use-cases (mentioned above) and thease are data-driven i.e., plugin just provide data to optimus.\nTo simplify the development process of plugins, support for yaml mode of defining plugins is added."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// representation of a yaml plugin schema in golang\n\n// below struct definition in golang can be marshalled \n// to generate yaml plugins\n\ntype YamlPlugin struct {\n    // info use-case\n    Name          string `yaml:"name"`\n    Description   string `yaml:"description"`\n    Plugintype    string `yaml:"plugintype"`\n    Pluginversion string `yaml:"pluginversion"`\n    Image         string `yaml:"image"`\n    Secretpath    string `yaml:"secretpath"`\n  \n    // survey use-case\n    Questions     []struct {\n        Name            string `yaml:"name"`\n        Prompt          string `yaml:"prompt"`\n        Help            string `yaml:"help"`\n        Regexp          string `yaml:"regexp"`\n        Validationerror string `yaml:"validationerror"`\n        Minlength       int    `yaml:"minlength"`\n        Required        bool     `yaml:"required,omitempty"`\n        Maxlength       int    `yaml:"maxlength,omitempty"`\n        Subquestions    []struct {\n            Ifvalue   string `yaml:"ifvalue"`\n            Questions []struct {\n                Name        string   `yaml:"name"`\n                Prompt      string   `yaml:"prompt"`\n                Help        string   `yaml:"help"`\n                Multiselect []string `yaml:"multiselect"`\n                Regexp          string `yaml:"regexp"`\n                Validationerror string `yaml:"validationerror"`\n                Minlength       int    `yaml:"minlength"`\n                Required        bool     `yaml:"required,omitempty"`\n                Maxlength       int    `yaml:"maxlength,omitempty"`\n            } `yaml:"questions"`\n        } `yaml:"subquestions,omitempty"`\n    } `yaml:"questions"`\n\n    // default-static-values use-case\n    Defaultassets []struct {\n        Name  string `yaml:"name"`\n        Value string `yaml:"value"`\n    } `yaml:"defaultassets"`\n    Defaultconfig []struct {\n        Name  string `yaml:"name"`\n        Value string `yaml:"value"`\n    } `yaml:"defaultconfig"`\n}\n')),(0,o.kt)("p",null,"refer to sample implemenation ",(0,o.kt)("a",{parentName:"p",href:"#2a-creating-a-yaml-plugin"},"here")),(0,o.kt)("h3",{id:"limitations-of-yaml-plugins"},"Limitations of Yaml plugins:"),(0,o.kt)("p",null,"Here the scope of yaml plugins is limited to drive survey, provide default values for job config and assets and provide plugin info. As majoiry of the plugins are expected to implement subset these use-cases, the support for yaml definitions for plugins is added which simplifies development, packaging and distribution of plugins."),(0,o.kt)("p",null,"For plugins that require to enrich optimus server side behaviour, yaml definitions falls short as this would require some code."),(0,o.kt)("h3",{id:"validating-yaml-plugins"},"Validating Yaml plugins:"),(0,o.kt)("p",null,"Also support for validating yaml plugin is added into optimus.\nAfter creating yaml definitions of plugin, one can validate them as below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"optimus plugin validate --path {{directory of yaml plugins}}\n")),(0,o.kt)("p",null,"** Note: The yaml plugin is expected to have file name as ",(0,o.kt)("inlineCode",{parentName:"p"},"optimus-plugin-{{name}}.yaml")),(0,o.kt)("p",null,"** Note: If Both yaml and binary plugin with same name are installed, Yaml implementation is prioritised over the corresponding counterparts in binary implemenation."),(0,o.kt)("h2",{id:"creating-plugin--tutorial"},"Creating Plugin : Tutorial"),(0,o.kt)("p",null,"To demonstrate the above mentioned wrapping functionality, let's create a plugin in Go as well as a yaml definition and use python for actual transformation logic. You can choose to fork this ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kushsharma/optimus-plugins"},"example")," template and modify it as per your needs or start fresh. To demonstrate how to start from scratch, we will be starting from an empty git repository and build a plugin which will find potential hazardous ",(0,o.kt)("strong",{parentName:"p"},"Near Earth Orbit")," objects every day, let's call it ",(0,o.kt)("strong",{parentName:"p"},"neo")," for short. "),(0,o.kt)("p",null,"Brief description of Neo is as follows"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Using  ",(0,o.kt)("a",{parentName:"li",href:"https://api.nasa.gov/"},"NASA API")," we can get count of hazardous objects, their diameter and velocity."),(0,o.kt)("li",{parentName:"ul"},"Task will need two config as input, ",(0,o.kt)("inlineCode",{parentName:"li"},"RANGE_START"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"RANGE_END")," as date time string which will filter the count for this specific period only."),(0,o.kt)("li",{parentName:"ul"},"Execute every day, say at 2 AM."),(0,o.kt)("li",{parentName:"ul"},"Need a secret token that will be passed to NASA api endpoint for each request."),(0,o.kt)("li",{parentName:"ul"},"Output of this object count can be printed in logs for now but in a real use case can be pushed to Kafka topic or written to a database."),(0,o.kt)("li",{parentName:"ul"},"Plugin will be written in ",(0,o.kt)("strong",{parentName:"li"},"Go")," and ",(0,o.kt)("strong",{parentName:"li"},"Neo")," in ",(0,o.kt)("strong",{parentName:"li"},"python"),".")),(0,o.kt)("h3",{id:"1-preparing-task-executor"},"1. Preparing task executor"),(0,o.kt)("p",null,"Start by initialising an empty git repository with the following folder structure"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},".git\n/task\n  /neo\n    /executor\n      /main.py\n      /requirements.txt\n      /Dockerfile\nREADME.md\n")),(0,o.kt)("p",null,"That is three folders one inside another. This might look confusing for now, a lot of things will, but just keep going. Create an empty python file in executor ",(0,o.kt)("inlineCode",{parentName:"p"},"main.py"),", this is where the main logic for interacting with nasa api and generating output will be. For simplicity, lets use as minimal things as possible."),(0,o.kt)("p",null,"Add the following code to ",(0,o.kt)("inlineCode",{parentName:"p"},"main.py")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'import os\nimport requests\nimport json\n\ndef start():\n    """\n    Sends a http call to nasa api, parses response and prints potential hazardous\n    objects in near earth orbit\n    :return:\n    """\n    opt_config = fetch_config_from_optimus()\n\n    # user configuration for date range\n    range_start = opt_config["envs"]["RANGE_START"]\n    range_end = opt_config["envs"]["RANGE_END"]\n\n    secret_key = os.environ["SECRET_KEY"]\n\n    # secret token required for NASA API being passed using job spec\n    api_key = json.loads(secret_key)\n    if api_key is None:\n        raise Exception("invalid api token")\n\n    # send the request for given date range\n    r = requests.get(url="https://api.nasa.gov/neo/rest/v1/feed",\n                     params={\'start_date\': range_start, \'end_date\': range_end, \'api_key\': api_key})\n\n    # extracting data in json format\n    print("for date range {} - {}".format(range_start, range_end))\n    print_details(r.json())\n\n    return\n  \n\ndef fetch_config_from_optimus():\n    """\n    Fetch configuration inputs required to run this task for a single schedule day\n    Configurations are fetched using optimus rest api\n    :return:\n    """\n    # try printing os env to see what all we have for debugging\n    # print(os.environ)\n\n    # prepare request\n    optimus_host = os.environ["OPTIMUS_HOSTNAME"]\n    scheduled_at = os.environ["SCHEDULED_AT"]\n    project_name = os.environ["PROJECT"]\n    job_name = os.environ["JOB_NAME"]\n\n    r = requests.post(url="http://{}/api/v1/project/{}/job/{}/instance".format(optimus_host, project_name, job_name),\n                      json={\'scheduled_at\': scheduled_at,\n                            \'instance_name\': "neo",\n                            \'instance_type\': "TASK"})\n    instance = r.json()\n\n    # print(instance)\n    return instance["context"]\n  \n \n  \nif __name__ == "__main__":\n    start()\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"api_key")," is a token provided by nasa during registration. This token will be passed as a parameter in each http call. ",(0,o.kt)("inlineCode",{parentName:"p"},"SECRET_PATH")," is the path to a file which will contain this token in json and will be mounted inside the docker container by Optimus."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"start")," function is using ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch_config_from_optimus()")," to get the date range for which this task executes for an iteration. In this example, configuration is fetched using REST APIs provided by optimus although there are variety of ways to get them. After extracting ",(0,o.kt)("inlineCode",{parentName:"p"},"API_KEY")," from secret file, unmarshalling it to json with ",(0,o.kt)("inlineCode",{parentName:"p"}," json.load()")," send a http request to nasa api. Response can be parsed and printed using the following function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def print_details(jd):\n    """\n    Parse and calculate what we need from NASA endpoint response\n\n    :param jd: json data fetched from NASA API\n    :return:\n    """\n    element_count = jd[\'element_count\']\n    potentially_hazardous = []\n    for search_date in jd[\'near_earth_objects\'].keys():\n        for neo in jd[\'near_earth_objects\'][search_date]:\n            if neo["is_potentially_hazardous_asteroid"] is True:\n                potentially_hazardous.append({\n                    "name": neo["name"],\n                    "estimated_diameter_km": neo["estimated_diameter"]["kilometers"]["estimated_diameter_max"],\n                    "relative_velocity_kmh": neo["close_approach_data"][0]["relative_velocity"]["kilometers_per_hour"]\n                })\n\n    print("total tracking: {}\\npotential hazardous: {}".format(element_count, len(potentially_hazardous)))\n    for haz in potentially_hazardous:\n        print("Name: {}\\nEstimated Diameter: {} km\\nRelative Velocity: {} km/h\\n\\n".format(\n            haz["name"],\n            haz["estimated_diameter_km"],\n            haz["relative_velocity_kmh"]\n        ))\n    return\n')),(0,o.kt)("p",null,"Finish it off by adding the main function"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'if __name__ == "__main__":\n    start()\n')),(0,o.kt)("p",null,"Add ",(0,o.kt)("inlineCode",{parentName:"p"},"requests")," library in ",(0,o.kt)("inlineCode",{parentName:"p"},"requirements.txt")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ini"},"requests==v2.25.1\n")),(0,o.kt)("p",null,"Once the python code is ready, wrap this in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Dockerfile")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dockerfile"},'# set base image (host OS)\nFROM python:3.8\n\n# set the working directory in the container\nRUN mkdir -p /opt\nWORKDIR /opt\n\n# copy the content of the local src directory to the working directory\nCOPY task/neo/executor .\n\n# install dependencies\nRUN pip install -r requirements.txt\n\nCMD ["python3", "main.py"]\n')),(0,o.kt)("h3",{id:"2a-creating-a-yaml-plugin"},"2a. Creating a yaml plugin"),(0,o.kt)("p",null,"The Yaml implementation is as simple as providing the plugin details as below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"name: Neo\ndescription: Near earth object tracker\nplugintype: task\npluginversion: latest\nimage: ghcr.io/kushsharma/optimus-task-neo-executor\nsecretpath: /tmp/.secrets\n\nquestions:\n- name: RANGE_START\n  prompt: Date range start\n  help: YYYY-MM-DD format\n  required: true\n- name: RANGE_END\n  prompt: Date range end\n  help: YYYY-MM-DD format\n  required: true\n")),(0,o.kt)("p",null,"Based on the usecase, additional validation can be added to the questions section. Refer ",(0,o.kt)("a",{parentName:"p",href:"#yaml-implementation-of-plugin"},"above")," for more usecases and features provided."),(0,o.kt)("h3",{id:"2b-creating-a-binary-plugin"},"2b. Creating a binary plugin"),(0,o.kt)("p",null,"At the moment Optimus supports task as well as hook plugins. In this section we will be explaining how to write a new task although both are very similar. "),(0,o.kt)("p",null,"Now that base image is ready for execution, this needs to be scheduled at a fixed interval using ",(0,o.kt)("inlineCode",{parentName:"p"},"jobs")," but for optimus to understand ",(0,o.kt)("strong",{parentName:"p"},"Neo")," task, we need to write an adapter for it."),(0,o.kt)("h4",{id:"implementing-plugin-interface"},"Implementing plugin interface"),(0,o.kt)("p",null,"Because we are using Go, start by initialising Go module in ",(0,o.kt)("inlineCode",{parentName:"p"},"neo")," directory as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"go mod init github.com/kushsharma/optimus-plugins/task/neo\n")),(0,o.kt)("p",null,"Prepare ",(0,o.kt)("inlineCode",{parentName:"p"},"main.go")," in the same directory structure"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},".git\n/task\n  /neo\n    /executor\n      /main.py\n      /requirements.txt\n      /Dockerfile\n    /main.go\n    /go.mod\n    /go.sum\nREADME.md\n")),(0,o.kt)("p",null,"Start by adding the following boilerplate code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "context"\n    "errors"\n    "fmt"\n    "strconv"\n\n    "github.com/hashicorp/go-hclog"\n    "github.com/odpf/optimus/internal/models"\n    "github.com/odpf/optimus/plugin"\n    "github.com/odpf/optimus/plugin/base"\n)\n\nvar (\n    Name    = "neo"\n    Version = "latest"\n    Image   = "ghcr.io/kushsharma/optimus-task-neo-executor"\n)\n\ntype Neo struct{}\n\nfunc main() {\n    plugin.Serve(func(log hclog.Logger) interface{} {\n        return &Neo{\n            log: log,\n        }\n    })\n}\n')),(0,o.kt)("p",null,"The plugin binary serves a GRPC server on start but before the communication channel is created protocol version, socket, port, and some other metadata needs to be printed as the handshake information to stdout which the core will read. Plugin and core needs to mutually conclude on same protocol version to start the communication. Client side protocol version announcement is done using ",(0,o.kt)("inlineCode",{parentName:"p"},"HandshakeConfig")," provided in ",(0,o.kt)("inlineCode",{parentName:"p"},"main()"),". "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Handshake contract:"),"\nCORE-PROTOCOL-VERSION | APP-PROTOCOL-VERSION | NETWORK-TYPE | NETWORK-ADDR | PROTOCOL"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"For example:")," "),(0,o.kt)("p",null,"1|1|tcp|127.0.0.1:1234|grpc"),(0,o.kt)("p",null,"You don't have to worry about this if you are using the provided ",(0,o.kt)("inlineCode",{parentName:"p"},"plugin.Serve")," and all this happens automatically behind the scene. Core will initiate a connection with the plugin server as a client when the core binary boots and caches the connection for further internal use."),(0,o.kt)("p",null,"A single binary can serve more than one kind of plugin, in this example stick with just one. Each plugin is composed of one ",(0,o.kt)("inlineCode",{parentName:"p"},"base")," plugin implementation and some additional optional ",(0,o.kt)("inlineCode",{parentName:"p"},"mods"),"."),(0,o.kt)("h4",{id:"base-plugin"},"Base Plugin"),(0,o.kt)("p",null,"Base plugin interface needs to be ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/proton/blob/54e0bec2df4235cabea4ac2127534a468584e932/odpf/optimus/plugins/base.proto"},"implemented")," by every plugin. It is responsible for providing plugin metadata to Optimus core."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\npackage odpf.optimus.plugins;\n\n// Base must be implemented by all plugins\nservice Base {\n    // PluginInfo provides basic details for this plugin\n    rpc PluginInfo(PluginInfoRequest) returns (PluginInfoResponse);\n}\n\n// PluginType enumerates the type of plugins Optimus supports\nenum PluginType {\n    PluginType_UNKNOWN = 0;\n    PluginType_TASK = 1;\n    PluginType_HOOK = 2;\n}\n\n// PluginMod enumerates the type of mods this plugin supports\nenum PluginMod {\n    PluginMod_UNKNOWN = 0;\n    PluginMod_CLI = 1;\n    PluginMod_DEPENDENCYRESOLVER = 2;\n}\n\n// HookType enumerates the type of hook Optimus supports\nenum HookType {\n    HookType_UNKNOWN = 0;\n    HookType_PRE = 1;\n    HookType_POST = 2;\n    HookType_FAIL = 3;\n}\n\nmessage PluginInfoRequest {}\nmessage PluginInfoResponse {\n    string name = 1;\n    string description = 2;\n    PluginType plugin_type = 3;\n    repeated PluginMod plugin_mods = 4;\n\n    // plugin_version is the semver version of this individual plugin\n    string plugin_version = 5;\n    // api_versions indicates the versions of the Optimus Plugin API\n    // this plugin supports\n    repeated string api_version = 6;\n\n    // docker image including version if this executes a docker image\n    string image = 10;\n\n    // HOOK specific\n    // name of hooks on which this should depend on before executing\n    repeated string depends_on = 20;\n    HookType hook_type = 21;\n\n    // Experimental\n    // will be mounted inside the container as volume\n    string secret_path = 30;\n}\n')),(0,o.kt)("p",null,"If your plugin simply wants to register itself as task or hook for execution and nothing else then that's it. You don't need to implement anything else but for additional features we can implement plugin ",(0,o.kt)("inlineCode",{parentName:"p"},"mod"),"."),(0,o.kt)("h4",{id:"plugin-mods"},"Plugin Mods"),(0,o.kt)("p",null,"Plugin can have none or many plugins mods being implemented at the same time. At the moment there are 2 mods available for usage"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/odpf/proton/blob/54e0bec2df4235cabea4ac2127534a468584e932/odpf/optimus/plugins/cli.proto"},"CLIMod"),": It provides plugin to interact with Optimus cli. Plugin can provide default configs, ask questions from users to create job specification, override default asset macro compilation behaviour, etc."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/odpf/proton/blob/54e0bec2df4235cabea4ac2127534a468584e932/odpf/optimus/plugins/dependency_resolver.proto"},"DependencyResolverMod"),": It provides plugin to implement automatic dependency resolution using assets/configs.")),(0,o.kt)("p",null,"In this example we will use the CLIMod."),(0,o.kt)("p",null,"To start serving GRPC, either we write our own implementation for serialising/deserialising Go structs to protobufs or reuse the one already provided by ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/optimus/blob/eaa50bb37d7e738d9b8a94332312f34b04a7e16b/plugin/task/server.go"},"core"),". Optimus GRPC server accepts an interface which we will implement next on Neo struct. Custom protobuf adapter can also be written using the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/proton/blob/54e0bec2df4235cabea4ac2127534a468584e932/odpf/optimus/plugins/base.proto"},"provided")," protobuf stored in odpf ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/proton"},"repository"),"."),(0,o.kt)("p",null,"Add the following code in the existing ",(0,o.kt)("inlineCode",{parentName:"p"},"main.go")," as an implementation to ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/proton/blob/54e0bec2df4235cabea4ac2127534a468584e932/odpf/optimus/plugins/base.proto"},"BasePlugin")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'type Neo struct{}\n\n// GetSchema provides basic task details\nfunc (n *Neo) PluginInfo() (*models.PluginInfoResponse, error) {\n    return &models.PluginInfoResponse{\n        Name:          Name,\n        Description:   "Near earth object tracker",\n        PluginType:    models.PluginTypeTask,\n        PluginMods:    []models.PluginMod{models.ModTypeCLI},\n        PluginVersion: Version,\n        APIVersion:    []string{strconv.Itoa(base.ProtocolVersion)},\n\n        // docker image that will be executed as the actual transformation task\n        Image: fmt.Sprintf("%s:%s", Image, Version),\n    }, nil\n}\n')),(0,o.kt)("p",null,"You might have noticed we have specified at line number 9 that we are supporting ",(0,o.kt)("inlineCode",{parentName:"p"},"models.ModTypeCLI"),". This will let Optimus know what all this plugin is capable of. Let's implement the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/proton/blob/54e0bec2df4235cabea4ac2127534a468584e932/odpf/optimus/plugins/cli.proto"},"CLIMod")," now."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'// GetQuestions provides questions asked via optimus cli when a new job spec\n// is requested to be created\nfunc (n *Neo) GetQuestions(ctx context.Context, req models.GetQuestionsRequest) (*models.GetQuestionsResponse, error) {\n    tQues := []models.PluginQuestion{\n        {\n            Name:   "Start",\n            Prompt: "Date range start",\n            Help:   "YYYY-MM-DD format",\n        },\n        {\n            Name:   "End",\n            Prompt: "Date range end",\n            Help:   "YYYY-MM-DD format",\n        },\n    }\n    return &models.GetQuestionsResponse{\n        Questions: tQues,\n    }, nil\n}\n\n// ValidateQuestion validate how stupid user is\n// Each question config in GetQuestions will send a validation request\nfunc (n *Neo) ValidateQuestion(ctx context.Context, req models.ValidateQuestionRequest) (*models.ValidateQuestionResponse, error) {\n    var err error\n    switch req.Answer.Question.Name {\n    case "Start":\n        err = func(ans interface{}) error {\n            d, ok := ans.(string)\n            if !ok || d == "" {\n                return errors.New("not a valid string")\n            }\n            // can choose to parse here for a valid date but we will use optimus\n            // macros here {{.DSTART}} instead of actual dates\n            // _, err := time.Parse(time.RFC3339, d)\n            // return err\n            return nil\n        }(req.Answer.Value)\n    case "End":\n        err = func(ans interface{}) error {\n            d, ok := ans.(string)\n            if !ok || d == "" {\n                return errors.New("not a valid string")\n            }\n            // can choose to parse here for a valid date but we will use optimus\n            // macros here {{.DEND}} instead of actual dates\n            // _, err := time.Parse(time.RFC3339, d)\n            // return err\n            return nil\n        }(req.Answer.Value)\n    }\n    if err != nil {\n        return &models.ValidateQuestionResponse{\n            Success: false,\n            Error:   err.Error(),\n        }, nil\n    }\n    return &models.ValidateQuestionResponse{\n        Success: true,\n    }, nil\n}\n\nfunc findAnswerByName(name string, answers []models.PluginAnswer) (models.PluginAnswer, bool) {\n    for _, ans := range answers {\n        if ans.Question.Name == name {\n            return ans, true\n        }\n    }\n    return models.PluginAnswer{}, false\n}\n\n// DefaultConfig are a set of key value pair which will be embedded in job\n// specification. These configs can be requested by the docker container before\n// execution\n// PluginConfig Value can contain valid go templates and they will be parsed at\n// runtime\nfunc (n *Neo) DefaultConfig(ctx context.Context, request models.DefaultConfigRequest) (*models.DefaultConfigResponse, error) {\n    start, _ := findAnswerByName("Start", request.Answers)\n    end, _ := findAnswerByName("End", request.Answers)\n\n    conf := []models.PluginConfig{\n        {\n            Name:  "RANGE_START",\n            Value: start.Value,\n        },\n        {\n            Name:  "RANGE_END",\n            Value: end.Value,\n        },\n    }\n    return &models.DefaultConfigResponse{\n        Config: conf,\n    }, nil\n}\n\n// DefaultAssets are a set of files which will be embedded in job\n// specification in assets folder. These configs can be requested by the\n// docker container before execution.\nfunc (n *Neo) DefaultAssets(ctx context.Context, _ models.DefaultAssetsRequest) (*models.DefaultAssetsResponse, error) {\n    return &models.DefaultAssetsResponse{}, nil\n}\n\n// override the compilation behaviour of assets - if needed\nfunc (n *Neo) CompileAssets(ctx context.Context, req models.CompileAssetsRequest) (*models.CompileAssetsResponse, error) {\n    return &models.CompileAssetsResponse{\n        Assets: req.Assets,\n    }, nil\n}\n')),(0,o.kt)("p",null,"All the functions are prefixed with comments to give you basic idea of what each one is doing, for advanced usage, look at other plugins used in the wild."),(0,o.kt)("p",null,"Few things to note:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PluginInfo")," is used to define a unique ",(0,o.kt)("inlineCode",{parentName:"li"},"name")," used by your plugin to identify yourself, keep it simple. "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PluginInfo")," contains ",(0,o.kt)("inlineCode",{parentName:"li"},"Image")," field that specify the docker image which Optimus will execute when needed. This is where the neo python image will go."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"Version")," field can be injected using build system, here we are only keeping a default value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"PluginType")," in ",(0,o.kt)("inlineCode",{parentName:"li"},"PluginInfo")," will tell of this plugin should be read as ",(0,o.kt)("inlineCode",{parentName:"li"},"Task")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"Hook")," by Optimus core.")),(0,o.kt)("h3",{id:"building-everything"},"Building everything"),(0,o.kt)("p",null,"Once the code is ready, to build there is a pretty nice tool available for golang ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/goreleaser/goreleaser/"},"goreleaser"),". A single configuration file will contain everything to build the docker image as well as the binary."),(0,o.kt)("p",null,"Put this in the root of the project as ",(0,o.kt)("inlineCode",{parentName:"p"},".goreleaser.yml")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'builds:\n  - dir: ./task/neo\n    main: .\n    id: "neo"\n    binary: "optimus-neo_{{.Os}}_{{.Arch}}"\n    ldflags:\n      - -s -w -X main.Version={{.Version}} -X main.Image=ghcr.io/kushsharma/optimus-task-neo-executor\n    goos:\n      - linux\n      - darwin\n      - windows\n    goarch:\n      - amd64\n      - arm64\n    env:\n      - CGO_ENABLED=0\narchives:\n  - replacements:\n      darwin: darwin\n      linux: linux\n      windows: windows\n      amd64: amd64\n    format_overrides:\n      - goos: windows\n        format: zip\nrelease:\n  prerelease: auto\nchecksum:\n  name_template: \'checksums.txt\'\nsnapshot:\n  name_template: "{{ .Tag }}-next"\nchangelog:\n  sort: asc\n  filters:\n    exclude:\n      - \'^docs:\'\n      - \'^test:\'\ndockers:\n  -\n    goos: linux\n    goarch: amd64\n    image_templates:\n    - "ghcr.io/kushsharma/optimus-task-neo-executor:latest"\n    - "ghcr.io/kushsharma/optimus-task-neo-executor:{{ .Version }}"\n    dockerfile: ./task/neo/executor/Dockerfile\n    extra_files:\n    - task/neo/executor\n\nbrews:\n  - name: optimus-plugins-kush\n    install: |\n      bin.install Dir["optimus-*"]\n    tap:\n      owner: kushsharma\n      name: homebrew-taps\n    license: "Apache 2.0"\n    description: "Optimus plugins - [Optimus Near earth orbit tracker]"\n    commit_author:\n      name: Kush Sharma\n      email: 3647166+kushsharma@users.noreply.github.com\n')),(0,o.kt)("p",null,"Please go through goreleaser documentation to understand what this config is doing but just to explain briefly"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It will build golang task plugin adapter for multiple platforms, archives them and release on Github"),(0,o.kt)("li",{parentName:"ul"},"Build and push the docker image for the python neo task"),(0,o.kt)("li",{parentName:"ul"},"Create a Formula for installing this plugin on Mac using brew"),(0,o.kt)("li",{parentName:"ul"},"Each plugin will follow the binary naming convention as ",(0,o.kt)("inlineCode",{parentName:"li"},"optimus-<pluginname>_<os>_<arch>"),". For example: ",(0,o.kt)("inlineCode",{parentName:"li"},"optimus-bq2bq_linux_amd64"))),(0,o.kt)("p",null,"Once installed, run goreleaser using"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"goreleaser --snapshot --rm-dist\n")),(0,o.kt)("p",null,"Use this ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kushsharma/optimus-plugins"},"repository")," as an example to see how everything fits in together. It uses github workflows to run goreleaser and publish everything."),(0,o.kt)("h2",{id:"how-to-use"},"How to use"),(0,o.kt)("h3",{id:"installing-a-plugin"},"Installing a plugin"),(0,o.kt)("p",null,"Plugins need to be installed in Optimus server before it can be used. Optimus uses following directories for discovering plugin binaries"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"./.plugins\n./\n<exec>/\n<exec>/.optimus/plugins\n$HOME/.optimus/plugins\n/usr/bin\n/usr/local/bin\n")),(0,o.kt)("p",null,"Even though the above list of directories are involved in plugin discovery, it is advised to use ",(0,o.kt)("inlineCode",{parentName:"p"},".plugins")," in the current working directory of the project or optimus binary."),(0,o.kt)("h3",{id:"server-side-installation"},"Server-side installation"),(0,o.kt)("p",null,"On Server side, plugins (both binary and yaml) can be installed declaratively at runtime by listing the plugin artifacts in plugins section of server config."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"optimus plugin install -c config.yaml  # This will install plugins in `.plugins` folder.\n")),(0,o.kt)("p",null,"Plugin section to be added in server config:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"plugin:\n  artifacts:\n    - https://...path/to/optimus-plugin-neo.yaml  # http \n    - http://.../plugins.zip # zip \n    - ../transformers/optimus-bq2bq_darwin_arm64 # relative paths\n    - ../transformers/optimus-plugin-neo.yaml\n")),(0,o.kt)("h3",{id:"project-side-installation"},"Project-side installation"),(0,o.kt)("p",null,"On the project side, where optimus cli is used to generate specifications or deployment, optimus cli can sync the yaml plugins supported-and-served by optimus server (with host as declared in project config)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"optimus plugin sync -c optimus.yaml    # This will install plugins in `.plugins` folder.\n")),(0,o.kt)("h3",{id:"using-in-job-specification"},"Using in job specification"),(0,o.kt)("p",null,"Once everything is built and in place, we can generate job specifications that uses ",(0,o.kt)("strong",{parentName:"p"},"neo")," as the task type."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"optimus create job\n? What is the job name? is_last_day_on_earth\n? Who is the owner of this job? kush.sharma@example.io\n? Which task to run? neo\n? Specify the start date 2021-05-25\n? Specify the interval (in crontab notation) 0 2 * * *\n? Transformation window daily\n? Date range start {{.DSTART}}\n? Date range end {{.DEND}}\njob created successfully is_last_day_on_earth\n")),(0,o.kt)("p",null,"Create a commit and deploy this specification if you are using optimus with a git managed repositories or send a REST call or use GRPC, whatever floats your boat."),(0,o.kt)("h3",{id:"checking-the-output"},"Checking the output"),(0,o.kt)("p",null,"If your optimus deployment is using Airflow as the scheduling engine, open the task log and verify something like this"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"total tracking: 14\npotential hazardous: 1\nName: (2014 KP4)\nEstimated Diameter: 0.8204270649 km\nRelative Velocity: 147052.9914506647 km/h\n")),(0,o.kt)("h2",{id:"additional-details"},"Additional details"),(0,o.kt)("p",null,"A task is like a pipeline, it takes some input, it runs a procedure on the input and then produces an output. Procedure is wrapped inside the docker image, output is owned by the procedure which could be anything but input should be injected somehow by optimus or at least provide some information about where/what input is. Currently, Optimus supports two kind of inputs:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Key value configuration"),(0,o.kt)("li",{parentName:"ul"},"File assets")),(0,o.kt)("h5",{id:"task-configuration"},"Task Configuration"),(0,o.kt)("p",null,"Task configurations are key value pair provided as part of job specification in ",(0,o.kt)("inlineCode",{parentName:"p"},"job.yaml")," file. These are based on plugin implementation of ",(0,o.kt)("inlineCode",{parentName:"p"},"TaskPlugin")," interface. These configurations accept simple strings as well as Optimus ",(0,o.kt)("a",{parentName:"p",href:"/optimus/docs/concepts/overview#Macros-&-Templates"},"macros"),". There are few Optimus provided configuration to all tasks and hooks even if users don't specifically provide them:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"DSTART"),(0,o.kt)("li",{parentName:"ul"},"DEND"),(0,o.kt)("li",{parentName:"ul"},"EXECUTION_TIME")),(0,o.kt)("p",null,"Secrets can be used in the task configuration by using macros like ",(0,o.kt)("inlineCode",{parentName:"p"},'SECRET_PATH: "{{.secret.api_key_path}}"'),".\nWhere ",(0,o.kt)("inlineCode",{parentName:"p"},"api_key_path")," is a value stored inside secrets. This configuration in macros will be replaced by optimus serer while sending a request to the plugin with actual value and can be used by the plugin. In the executor of the plugin, this configuration will be made available as environment variable."),(0,o.kt)("h5",{id:"file-assets"},"File Assets"),(0,o.kt)("p",null,"Sometimes a task may need more than just key value configuration, this is where assets can be used. Assets are packed along with the job specification and should have unique names. A task can have more than one asset file but if any file name conflicts with any already existing plugin in the optimus, it will throw an error, so it is advised to either prefix them or name them very specific to the task. These assets should ideally be small and not more than ~5 MB and any heavy lifting if required should be done directly inside the task container."),(0,o.kt)("h3",{id:"requesting-task-context"},"Requesting task context"),(0,o.kt)("p",null,"Optimus calls these task configuration and asset inputs for each scheduled execution of a task as ",(0,o.kt)("inlineCode",{parentName:"p"},"context"),". There are variety of ways to fetch task context from optimus."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"REST API"),(0,o.kt)("li",{parentName:"ul"},"GRPC function call"),(0,o.kt)("li",{parentName:"ul"},"Optimus cli")),(0,o.kt)("h5",{id:"rest-api"},"REST API"),(0,o.kt)("p",null,"This is probably the easiest way using ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/optimus/blob/0ab5a4d44a7b2b85e9a160aef3648d8ba798536a/third_party/OpenAPI/odpf/optimus/runtime_service.swagger.json#L187"},"REST API")," provided by optimus server. Each container when boots up has few pre-defined environment variables injected by optimus, few of them are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"JOB_NAME"),(0,o.kt)("li",{parentName:"ul"},"OPTIMUS_HOSTNAME"),(0,o.kt)("li",{parentName:"ul"},"JOB_DIR"),(0,o.kt)("li",{parentName:"ul"},"PROJECT"),(0,o.kt)("li",{parentName:"ul"},"SCHEDULED_AT"),(0,o.kt)("li",{parentName:"ul"},"INSTANCE_TYPE"),(0,o.kt)("li",{parentName:"ul"},"INSTANCE_NAME")),(0,o.kt)("p",null,"These variables might be needed to make the call and in response, container should get configuration and files as key value pairs in json."),(0,o.kt)("h5",{id:"grpc-call"},"GRPC call"),(0,o.kt)("p",null,"Plugin can choose to make a GRPC call using ",(0,o.kt)("inlineCode",{parentName:"p"},"RegisterInstance")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/odpf/proton/blob/main/odpf/optimus/runtime_service.proto#L124"},"function")," and should get the context back in return."),(0,o.kt)("h5",{id:"optimus-cli"},"Optimus cli"),(0,o.kt)("p",null,"There could be scenarios where it is not possible or maybe not convenient to modify the base execution image and still task need context configuration values. One easy way to do this is by wrapping the base docker image into another docker image and using optimus binary to request task context. Optimus command will internally send a GRPC call and store the output in ",(0,o.kt)("inlineCode",{parentName:"p"},"${JOB_DIR}/in/")," directory. It will create one ",(0,o.kt)("inlineCode",{parentName:"p"},".env")," file containing all the configurations, one ",(0,o.kt)("inlineCode",{parentName:"p"},".secret")," file with environment variables with potentially sensitive values, and all the asset files belong to the provided task. Optimus command can be invoked as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"OPTIMUS_ADMIN_ENABLED=1 /opt/optimus admin build instance $JOB_NAME --project $PROJECT --output-dir $JOB_DIR --type $INSTANCE_TYPE --name $INSTANCE_NAME --scheduled-at $SCHEDULED_AT --host $OPTIMUS_HOSTNAME\n")),(0,o.kt)("p",null,"You might have noticed, optimus need OPTIMUS_ADMIN_ENABLED as env variable to enable admin commands. An example of wrapper ",(0,o.kt)("inlineCode",{parentName:"p"},"Dockerfile")," is as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dockerfile"},'FROM ghcr.io/kushsharma/optimus-task-neo-executor:latest\n\n# path to optimus release tar.gz\nARG OPTIMUS_RELEASE_URL\n\nRUN apt install curl tar -y\nRUN mkdir -p /opt\nRUN curl -sL ${OPTIMUS_RELEASE_URL} | tar xvz optimus\nRUN mv optimus /opt/optimus || true\nRUN chmod +x /opt/optimus\n\n# or copy like this\nCOPY task/neo/example.entrypoint.sh /opt/entrypoint.sh\nRUN chmod +x /opt/entrypoint.sh\n\nENTRYPOINT ["/opt/entrypoint.sh"]\nCMD ["python3", "/opt/main.py"]\n')),(0,o.kt)("p",null,"Where ",(0,o.kt)("inlineCode",{parentName:"p"},"entrypoint.sh")," is as follows"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},'#!/bin/sh\n# wait for few seconds to prepare scheduler for the run\nsleep 5\n\n# get resources\necho "-- initializing optimus assets"\nOPTIMUS_ADMIN_ENABLED=1 /opt/optimus admin build instance $JOB_NAME --project $PROJECT --output-dir $JOB_DIR --type $TASK_TYPE --name $TASK_NAME --scheduled-at $SCHEDULED_AT --host $OPTIMUS_HOSTNAME\n\n# TODO: this doesnt support using back quote sign in env vars\necho "-- exporting env"\nset -o allexport\nsource $JOB_DIR/in/.env\nset +o allexport\n\necho "-- current envs"\nprintenv\n\necho "-- exporting secret envs"\nset -o allexport\nsource $JOB_DIR/in/.secret\nset +o allexport\n\necho "-- running unit"\nexec $(eval echo "$@")\n')),(0,o.kt)("p",null,"All of it can be built using goreleaser as well"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'dockers:\n  -\n    goos: linux\n    goarch: amd64\n    image_templates:\n    - "ghcr.io/kushsharma/optimus-task-neo:latest"\n    - "ghcr.io/kushsharma/optimus-task-neo:{{ .Version }}"\n    dockerfile: ./task/neo/example.Dockerfile\n    extra_files:\n    - task/neo/example.entrypoint.sh\n    build_flag_templates:\n    - "--build-arg=OPTIMUS_RELEASE_URL=https://github.com/odpf/optimus/releases/download/v0.0.1-rc.2/optimus_0.0.1-rc.2_linux_x86_64.tar.gz"\n')),(0,o.kt)("p",null,"Keep in mind, the plugin binary now needs to point to this ",(0,o.kt)("inlineCode",{parentName:"p"},"optimus-task-neo")," docker image and not the base one. An example of this approach can be checked in the provided ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/kushsharma/optimus-plugins"},"repository"),"."),(0,o.kt)("h3",{id:"directory-structure"},"Directory Structure"),(0,o.kt)("p",null,"You might have already understood it by now but still just to state, the reason we went ahead with the provided directory structure earlier so that we can support more than one task and even hooks if we need to in the same repository. Image a single repository of plugins as an organization repository where one can find all that can be contributed by an entity"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"/task\n  /neo\n    /executor\n      /main.py\n      /requirements.txt\n      /Dockerfile\n    /main.go\n    /go.mod\n    /go.sum\n  /task-2\n  /task-3\n/hook\n  /hook-1\n  /hook-2\n.goreleaser.yml\nREADME.md\n")),(0,o.kt)("h3",{id:"secret-management"},"Secret management"),(0,o.kt)("p",null,"You must be wondering from where that api token came from when we said it will be mounted inside the container. Optimus need to somehow know what the secret is, for this current implementation of optimus relies on Kubernetes ",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/configuration/secret/"},"Secrets"),". Optimus is built to be deployed on kubernetes, although it can work just fine without it as well but might need some tweaking here and there. An example of creating this secret "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Secret\nmetadata:\n  name: optimus-task-neo\ntype: Opaque\ndata:\n  key.json: base64encodedAPIkeygoes\n")),(0,o.kt)("p",null,"Notice the name of the secret ",(0,o.kt)("inlineCode",{parentName:"p"},"optimus-task-neo")," which is actually based on a convention. That is if secret is defined, Optimus will look in kubernetes using ",(0,o.kt)("inlineCode",{parentName:"p"},"optimus-task-<taskname>")," as the secret name and mount it to the path provided in ",(0,o.kt)("inlineCode",{parentName:"p"},"SecretPath")," field of ",(0,o.kt)("inlineCode",{parentName:"p"},"PluginInfo"),"."),(0,o.kt)("p",null,"There is also a new way to using secrets in the job for a plugin or otherwise, we can store a user defined secret in the optimus server with the following command"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"optimus secret set secret_name <secret_value>\n")),(0,o.kt)("p",null,"Verify if the secret is registered properly with optimus server using following command"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"optimus secret list\n")),(0,o.kt)("p",null,"It should list the secret registered above."),(0,o.kt)("p",null,"Then we can mention the secret in the job spec configuration like mentioned in the Task Configuration section. The configuration with secrets will be made available to the calls to plugins on dependency mod, and set as environment variable in the executor used by the scheduler."))}m.isMDXComponent=!0}}]);